using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MicrotypeGenerator.Generators;

[Generator]
public sealed class MicroTypeIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Generate the MicroTypeAttribute<T> class
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("MicroTypeAttribute.g.cs", SourceText.From("""
                // <auto-generated/>
                using System;

                /// <summary>
                /// Marks a partial type to be expanded as a microtype wrapping the specified primitive type T.
                /// </summary>
                /// <typeparam name="T">The primitive type being wrapped.</typeparam>
                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
                public class MicroTypeAttribute<T> : Attribute;
                """, Encoding.UTF8));
        });

        var candidates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "MicroTypeAttribute`1",
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (ctx, _) =>
                {
                    var symbol = ctx.TargetSymbol as INamedTypeSymbol;
                    if (symbol is null)
                        return (MicroTypeTarget?)null;

                    // Try to get the generic type argument from the attribute's class type arguments
                    var attr = ctx.Attributes[0];
                    ITypeSymbol? innerType = null;
                    if (attr.AttributeClass is INamedTypeSymbol namedAttr && namedAttr.TypeArguments.Length > 0)
                    {
                        innerType = namedAttr.TypeArguments[0];
                    }

                    return new MicroTypeTarget(symbol, innerType);
                })
            .Where(static t => t.HasValue)
            .Select(static (t, _) => t!.Value);

        context.RegisterSourceOutput(candidates, static (spc, item) =>
        {
            try
            {
                var code = GenerateSource(item);
                var hintName = GetHintName(item.Symbol);
                spc.AddSource(hintName, SourceText.From(code, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                // swallow exceptions from generation to avoid breaking compilation
                var diag = Diagnostic.Create(new DiagnosticDescriptor("MTG001", "Generator error", ex.Message, "MicroTypeGenerator", DiagnosticSeverity.Warning, true), Location.None);
                spc.ReportDiagnostic(diag);
            }
        });
    }

    private static string GetHintName(INamedTypeSymbol symbol)
    {
        var ns = symbol.ContainingNamespace?.ToDisplayString() ?? "";
        var name = symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat).Replace("<", "_").Replace(">", "_").Replace(".", "_");
        if (string.IsNullOrWhiteSpace(ns))
            return name + ".g.cs";
        return ns + "." + name + ".g.cs";
    }

    private static string GenerateSource(MicroTypeTarget target)
    {
        var symbol = target.Symbol;
        var innerType = target.InnerType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

        var ns = symbol.ContainingNamespace?.ToDisplayString();
        var namespaceDeclaration = !string.IsNullOrEmpty(ns) ? $"namespace {ns};" : "";

        // Type declaration components
        var typeKind = symbol.TypeKind == TypeKind.Struct ? "struct" : "class";
        var nameWithTypeParams = symbol.Name;
        if (symbol.TypeParameters.Length > 0)
        {
            var tpList = string.Join(", ", symbol.TypeParameters.Select(p => p.ToDisplayString()));
            nameWithTypeParams += "<" + tpList + ">";
        }

        var accessibility = symbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => "public"
        };

        var implements = $": System.IEquatable<{symbol.Name}>, System.Numerics.IEqualityOperators<{symbol.Name}, {symbol.Name}, bool>";

        // Member generation flags
        var fieldAccessibility = symbol.IsSealed ? "private readonly" : "protected readonly";
        var hasParse = symbol.GetMembers().Any(m => m.Name == "Parse");
        var parseAccessibility = symbol.IsSealed ? "" : "protected ";
        var hasEqualsObj = symbol.GetMembers().OfType<IMethodSymbol>()
            .Any(m => m.Name == "Equals" && m.Parameters.Length == 1 && m.Parameters[0].Type.SpecialType == SpecialType.System_Object);
        var hasEqualsOther = symbol.GetMembers().OfType<IMethodSymbol>()
            .Any(m => m.Name == "Equals" && m.Parameters.Length == 1 && m.Parameters[0].Type.Name == symbol.Name);
        var hasGetHash = symbol.GetMembers().Any(m => m.Name == "GetHashCode");
        var hasToString = symbol.GetMembers().Any(m => m.Name == "ToString");
        var hasEqOp = symbol.GetMembers().Any(m => m.Name == "op_Equality");
        var hasNeOp = symbol.GetMembers().Any(m => m.Name == "op_Inequality");
        var isStruct = symbol.TypeKind == TypeKind.Struct;
        var nullability = isStruct ? "" : "?";

        // Build optional members
        var parseMethod = !hasParse ? $$"""
                
                [System.Diagnostics.Contracts.Pure]
                {{parseAccessibility}}{{innerType}} Parse(in {{innerType}} source) => source;
            """ : "";

        var equalsObjMethod = !hasEqualsObj ? $$"""
                
                public override bool Equals(object? obj) =>
                    obj is {{symbol.Name}} { inner: var other } && inner.Equals(other);
            """ : "";

        var equalsOtherMethod = !hasEqualsOther
            ? isStruct
                ? $$"""
                        
                        public bool Equals({{symbol.Name}} other) => inner == other.inner;
                    """
                : $$"""
                        
                        public bool Equals({{symbol.Name}}? other) => inner == other?.inner;
                    """
            : "";

        var getHashMethod = !hasGetHash ? """
                
                public override int GetHashCode() => inner.GetHashCode();
            """ : "";

        var toStringMethod = !hasToString ? """
                
                public override string ToString() => inner.ToString();
            """ : "";

        var equalityOp = !hasEqOp
            ? isStruct
                ? $$"""
                        
                        public static bool operator ==({{symbol.Name}} left, {{symbol.Name}} right) => left.Equals(right);
                    """
                : $$"""
                        
                        public static bool operator ==({{symbol.Name}}? left, {{symbol.Name}}? right) => left?.Equals(right) ?? right is null;
                    """
            : "";

        var inequalityOp = !hasNeOp
            ? $$"""
                    
                    public static bool operator !=({{symbol.Name}}{{nullability}} left, {{symbol.Name}}{{nullability}} right) => !(left == right);
                """
            : "";

        return $$"""
            {{namespaceDeclaration}}

            // <auto-generated/>
            #nullable enable

            {{accessibility}} partial {{typeKind}} {{nameWithTypeParams}} {{implements}}
            {
                {{fieldAccessibility}} {{innerType}} inner;

                public {{symbol.Name}}({{innerType}} value) => inner = Parse(value);
            {{parseMethod}}{{equalsObjMethod}}{{equalsOtherMethod}}{{getHashMethod}}{{toStringMethod}}{{equalityOp}}{{inequalityOp}}

                public static implicit operator {{innerType}}({{symbol.Name}} value) => value.inner;

                public static implicit operator {{symbol.Name}}({{innerType}} value) => new {{symbol.Name}}(value);
            }
            """;
    }

    private readonly struct MicroTypeTarget(
        INamedTypeSymbol symbol,
        ITypeSymbol? innerType) : IEquatable<MicroTypeTarget>
    {
        public INamedTypeSymbol Symbol { get; } = symbol;
        public ITypeSymbol? InnerType { get; } = innerType;

        public bool Equals(MicroTypeTarget other) =>
            SymbolEqualityComparer.Default.Equals(Symbol, other.Symbol) &&
            SymbolEqualityComparer.Default.Equals(InnerType, other.InnerType);

        public override bool Equals(object? obj) =>
            obj is MicroTypeTarget other && Equals(other);

        public override int GetHashCode() =>
            HashCode.Combine(
                SymbolEqualityComparer.Default.GetHashCode(Symbol),
                InnerType is not null ? SymbolEqualityComparer.Default.GetHashCode(InnerType) : 0);
    }
}
