using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using static Microsoft.CodeAnalysis.SymbolEqualityComparer;

namespace MicrotypeGenerator.Generators;

[Generator]
public sealed class MicroTypeIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Generate the MicroTypeAttribute<T> class
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("MicroTypeAttribute.g.cs", SourceText.From("""
                // <auto-generated/>
                using System;

                /// <summary>
                /// Marks a partial type to be expanded as a microtype wrapping the specified primitive type T.
                /// </summary>
                /// <typeparam name="T">The primitive type being wrapped.</typeparam>
                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
                public class MicroTypeAttribute<T> : Attribute;
                """, Encoding.UTF8));
        });

        var candidates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "MicroTypeAttribute`1",
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (ctx, _) =>
                {
                    var symbol = ctx.TargetSymbol as INamedTypeSymbol;
                    if (symbol is null)
                        return (MicroTypeTarget?)null;

                    // Try to get the generic type argument from the attribute's class type arguments
                    var attr = ctx.Attributes[0];
                    ITypeSymbol? innerType = null;
                    if (attr.AttributeClass is INamedTypeSymbol namedAttr && namedAttr.TypeArguments.Length > 0)
                    {
                        innerType = namedAttr.TypeArguments[0];
                    }

                    return new MicroTypeTarget(symbol, innerType);
                })
            .Where(static t => t.HasValue)
            .Select(static (t, _) => t!.Value);

        context.RegisterSourceOutput(candidates, static (spc, item) =>
        {
            try
            {
                var code = GenerateSource(item);
                var hintName = GetHintName(item.Symbol);
                spc.AddSource(hintName, SourceText.From(code, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                // swallow exceptions from generation to avoid breaking compilation
                var diag = Diagnostic.Create(new DiagnosticDescriptor("MTG001", "Generator error", ex.Message, "MicroTypeGenerator", DiagnosticSeverity.Warning, true), Location.None);
                spc.ReportDiagnostic(diag);
            }
        });
    }

    private static string GetHintName(INamedTypeSymbol symbol)
    {
        var ns = symbol.ContainingNamespace?.ToDisplayString() ?? "";
        var name = symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var safeName = new StringBuilder(name.Length);
        foreach (var c in name)
            safeName.Append(c is '<' or '>' or '.' ? '_' : c);
        if (string.IsNullOrWhiteSpace(ns))
            return safeName + ".g.cs";
        return ns + "." + safeName + ".g.cs";
    }

    private static string GenerateSource(MicroTypeTarget target)
    {
        var symbol = target.Symbol;
        var innerType = target.InnerType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "object";

        var @namespace = symbol.ContainingNamespace?.ToDisplayString();
        var namespaceDeclaration = !string.IsNullOrEmpty(@namespace) ? $"namespace {@namespace};" : "";

        // Type declaration components
        var typeKind = symbol.TypeKind == TypeKind.Struct ? "struct" : "class";
        var nameWithTypeParams = symbol.Name;
        if (symbol.TypeParameters.Length == 1)
            nameWithTypeParams += "<" + symbol.TypeParameters[0].ToDisplayString() + ">";
        else if (symbol.TypeParameters.Length > 1)
            nameWithTypeParams += "<" + string.Join(
                ", ",
                symbol.TypeParameters.Select(p => p.ToDisplayString())) + ">";

        var accessibility = symbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => "public"
        };

        var implements = $": System.IEquatable<{symbol.Name}>, System.Numerics.IEqualityOperators<{symbol.Name}, {symbol.Name}, bool>";

        // Member generation flags
        var fieldAccessibility = symbol.IsSealed ? "private readonly" : "protected readonly";
        var parseAccessibility = symbol.IsSealed ? "" : "protected ";

        var isStruct = symbol.TypeKind == TypeKind.Struct;
        var nullability = isStruct ? "" : "?";

        var hasParse = false;
        var hasEqualsObj = false;
        var hasEqualsOther = false;
        var hasGetHash = false;
        var hasToString = false;
        var hasEqOp = false;
        var hasNeOp = false;

        foreach (var member in symbol.GetMembers())
        {
            switch (member)
            {
                case IMethodSymbol { Name: "Parse", ReturnType: var ret, Parameters: [{ RefKind: RefKind.In, Type: var param }] }
                    when !hasParse && Default.Equals(param, target.InnerType) && Default.Equals(ret, target.InnerType):
                    hasParse = true;
                    break;

                case IMethodSymbol { Name: "Equals", ReturnType.SpecialType: SpecialType.System_Boolean, Parameters: [{ Type.SpecialType: SpecialType.System_Object }] }
                    when !hasEqualsObj:
                    hasEqualsObj = true;
                    break;

                case IMethodSymbol { Name: "Equals", ReturnType.SpecialType: SpecialType.System_Boolean, Parameters: [{ Type: var param }] }
                    when !hasEqualsOther && Default.Equals(param, symbol):
                    hasEqualsOther = true;
                    break;

                case IMethodSymbol { Name: "GetHashCode", Parameters.Length: 0, ReturnType.SpecialType: SpecialType.System_Int32 }
                    when !hasGetHash:
                    hasGetHash = true;
                    break;

                case IMethodSymbol { Name: "ToString", Parameters.Length: 0, ReturnType.SpecialType: SpecialType.System_String }
                    when !hasToString:
                    hasToString = true;
                    break;

                case IMethodSymbol { Name: "op_Equality", ReturnType.SpecialType: SpecialType.System_Boolean, Parameters: [{ Type: var left }, { Type: var right }] }
                    when !hasEqOp && Default.Equals(left, symbol) && Default.Equals(right, symbol):
                    hasEqOp = true;
                    break;

                case IMethodSymbol { Name: "op_Inequality", ReturnType.SpecialType: SpecialType.System_Boolean, Parameters: [{ Type: var left }, { Type: var right }] }
                    when !hasNeOp && Default.Equals(left, symbol) && Default.Equals(right, symbol):
                    hasNeOp = true;
                    break;
            }

            if (hasParse && hasEqualsObj && hasEqualsOther && hasGetHash && hasToString && hasEqOp && hasNeOp)
                break;
        }

        // Build optional members
        var members = new StringBuilder(512);

        if (!hasParse)
            members.Append($$"""

                [System.Diagnostics.Contracts.Pure]
                {{parseAccessibility}}{{innerType}} Parse(in {{innerType}} source) => source;
            """);

        if (!hasEqualsObj)
            members.Append($$"""

                public override bool Equals(object? obj) =>
                    obj is {{symbol.Name}} { inner: var other } && inner.Equals(other);
            """);

        if (!hasEqualsOther)
        {
            if (isStruct)
                members.Append($$"""

                public bool Equals({{symbol.Name}} other) => inner == other.inner;
            """);
            else
                members.Append($$"""

                public bool Equals({{symbol.Name}}? other) => inner == other?.inner;
            """);
        }

        if (!hasGetHash)
            members.Append("""

                public override int GetHashCode() => inner.GetHashCode();
            """);

        if (!hasToString)
            members.Append("""

                public override string ToString() => inner.ToString();
            """);

        if (!hasEqOp)
        {
            if (isStruct)
                members.Append($$"""

                public static bool operator ==({{symbol.Name}} left, {{symbol.Name}} right) => left.Equals(right);
            """);
            else
                members.Append($$"""

                public static bool operator ==({{symbol.Name}}? left, {{symbol.Name}}? right) => left?.Equals(right) ?? right is null;
            """);
        }

        if (!hasNeOp)
            members.Append($$"""

                public static bool operator !=({{symbol.Name}}{{nullability}} left, {{symbol.Name}}{{nullability}} right) => !(left == right);
            """);

        return $$"""
            {{namespaceDeclaration}}

            // <auto-generated/>
            #nullable enable

            {{accessibility}} partial {{typeKind}} {{nameWithTypeParams}} {{implements}}
            {
                {{fieldAccessibility}} {{innerType}} inner;

                public {{symbol.Name}}({{innerType}} value) => inner = Parse(value);
            {{members}}

                public static implicit operator {{innerType}}({{symbol.Name}} value) => value.inner;

                public static implicit operator {{symbol.Name}}({{innerType}} value) => new {{symbol.Name}}(value);
            }
            """;
    }

    private readonly struct MicroTypeTarget(
        INamedTypeSymbol symbol,
        ITypeSymbol? innerType) : IEquatable<MicroTypeTarget>
    {
        public INamedTypeSymbol Symbol { get; } = symbol;
        public ITypeSymbol? InnerType { get; } = innerType;

        public bool Equals(MicroTypeTarget other) =>
            Default.Equals(Symbol, other.Symbol) &&
            Default.Equals(InnerType, other.InnerType);

        public override bool Equals(object? obj) =>
            obj is MicroTypeTarget other && Equals(other);

        public override int GetHashCode() =>
            HashCode.Combine(
                Default.GetHashCode(Symbol),
                InnerType is not null ? Default.GetHashCode(InnerType) : 0);
    }
}
